package main // 声明程序的主包，Go程序必须属于某个包，main包是程序的入口

import "fmt" // 导入fmt包，用于格式化输入输出操作，如打印到控制台

func CountValidPBFTSystems(matrix [][2]int) int { // 定义一个函数，接收一个由[2]int类型数组组成的切片作为参数，返回一个整数
	count := 0 // 初始化一个计数器，用于记录满足PBFT条件的系统数量
	//请在下方补全代码=============
	for _, system := range matrix { // 使用for...range循环遍历matrix切片中的每个[2]int数组，_表示忽略索引，system是当前数组
		n := system[0]     // 从数组的第一个元素提取总节点数n，存储在变量n中
		fMax := system[1]  // 从数组的第二个元素提取拜占庭节点数fMax，存储在变量fMax中
		if 3*fMax+1 <= n { // 检查PBFT条件：3f + 1 ≤ n，确保系统能容忍fMax个拜占庭节点
			count++ // 如果条件满足，计数器加1，表示当前系统是有效的PBFT系统
		}
	}
	//请在上方补全代码=============
	return count // 返回满足PBFT条件的系统总数
}

func main() { // 定义main函数，作为程序的入口点，程序从这里开始执行
	testMatrix := [][2]int{ // 创建一个由[2]int数组组成的切片，用于测试，包含三组测试用例
		{4, 1}, // 第一个测试用例：总节点数为4，拜占庭节点数为1
		{7, 2}, // 第二个测试用例：总节点数为7，拜占庭节点数为2
		{3, 0}, // 第三个测试用例：总节点数为3，拜占庭节点数为0
	}
	result := CountValidPBFTSystems(testMatrix) // 调用CountValidPBFTSystems函数，传入testMatrix，获取满足条件的系统数量并存储在result中
	fmt.Printf("满足 PBFT 条件的系统数量: %d\n", result) // 使用fmt.Printf格式化输出结果，打印满足PBFT条件的系统数量，%d是result的占位符，\n换行
}